/*
 * Copyright (C) 2006-2009 TopCoder Inc., All Rights Reserved.
 */
package com.topcoder.management.scorecard.persistence;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.List;

import com.topcoder.management.scorecard.PersistenceException;
import com.topcoder.management.scorecard.persistence.logging.LogMessage;
import com.topcoder.util.idgenerator.IDGenerationException;
import com.topcoder.util.idgenerator.IDGenerator;
import com.topcoder.util.log.Level;
import com.topcoder.util.log.Log;
import com.topcoder.util.log.LogManager;

/**
 * <p>
 * Helper class that maintain common database methods used in this component.
 * </p>
 *
 * <p>
 * Changes in v1.0.2 (Cockpit Spec Review Backend Service Update v1.0):
 * - added flag to rollBack method so that container transaction demarcation can be used.
 * - LogManager is used instead of LogFactory.
 * </p>
 *
 * @author kr00tki, pulky
 * @version 1.0.2
 */
final class DBUtils {

    /**
     * Logger instance.
     */
    private static final Log logger = LogManager.getLog(DBUtils.class.getName());

    /**
     * Empty constructor.
     */
    private DBUtils() {
    }

    /**
     * Closes the connection.
     *
     * @param conn the connection.
     */
    public static void close(Connection conn) {
        if (conn != null) {
            try {
                logger.log(Level.INFO, "close the connection.");
                conn.close();
            } catch (SQLException e) {
                // ignore
            }
        }
    }

    /**
     * Closes the statement.
     *
     * @param stmt the statement.
     */
    public static void close(Statement stmt) {
        if (stmt != null) {
            try {
                stmt.close();
            } catch (SQLException e) {
                // ignore
            }
        }
    }

    /**
     * Closes the result set.
     *
     * @param rs the result set.
     */
    public static void close(ResultSet rs) {
        if (rs != null) {
            try {
                rs.close();
            } catch (SQLException e) {
                // ignore
            }
        }
    }

    /**
     * Roll backs the transaction.
     *
     * @param conn connection.
     * @param useManualCommit whether this component should use manual commit or not.
     */
    public static void rollback(Connection conn, boolean useManualCommit) {
        try {
            if(useManualCommit) {
                logger.log(Level.INFO, "rollback the connection.");
                conn.rollback();
            }
        } catch (SQLException ex) {
            // ignore
        }
    }

    /**
     * <p>
     * Checks if the given array is not <code>null</code> or empty and if the values are positive.
     *
     * @param array the array to be checked.
     * @param name the name of the argument. Used for the exception message.
     * @throws IllegalArgumentException if array is <code>null</code> or empty or contains negatize or zero
     *         value.
     */
    public static void checkIdsArray(long[] array, String name) {
        if (array == null) {
            throw new IllegalArgumentException(name + " cannot be null.");
        }

        if (array.length == 0) {
            throw new IllegalArgumentException("The ids array cannot be empty.");
        }

        for (int i = 0; i < array.length; i++) {
            if (array[i] <= 0) {
                throw new IllegalArgumentException("The ids array contains non-positive value at: " + i);
            }
        }
    }

    /**
     * <p>
     * Returns new unique id generated by the given IDGenerator.
     * </p>
     *
     * @param generator the IDGenerator to be used.
     * @return the unique id.
     * @throws PersistenceException if error occur while generating the id.
     */
    public static long nextId(IDGenerator generator) throws PersistenceException {
        try {
            long id =  generator.getNextID();
            logger.log(Level.INFO, "Generate next id using the idgenerator:" + generator.getIDName());
            return id;
        } catch (IDGenerationException ex) {
            logger.log(Level.ERROR, "Fail to generate next id using the idgenerator:"
                    + generator.getIDName() + "\n" + LogMessage.getExceptionStackTrace(ex));
            throw new PersistenceException("Error occur while generating new id.", ex);
        }
    }

    /**
     * Generates the array of unique ids using the given IDGenerator.
     *
     * @param length the number of ids to generate.
     * @param idGenerator the IDGenerator to be used.
     * @return the array of ids.
     * @throws PersistenceException if error occurs while generating the ids.
     */
    public static long[] generateIdsArray(int length, IDGenerator idGenerator) throws PersistenceException {
        long[] result = new long[length];

        try {
            for (int i = 0; i < result.length; i++) {
                result[i] = idGenerator.getNextID();
                logger.log(Level.INFO, "Generate next id using the idgenerator:" + idGenerator.getIDName());
            }
        } catch (IDGenerationException ex) {
            logger.log(Level.ERROR, "Fail to generate next id using the idgenerator:"
                    + idGenerator.getIDName() + "\n" + LogMessage.getExceptionStackTrace(ex));
            throw new PersistenceException("Error occur while generating new id.", ex);
        }

        return result;
    }

    /**
     * Creates the string in the pattern (?,+) where count is the number of question marks.
     * It is used th build prepared statements with IN condition.
     *
     * @param count number of question marks.
     * @return the string of question marks.
     */
    static String createQuestionMarks(int count) {
        StringBuffer buff = new StringBuffer();
        buff.append("(?");
        for (int i = 1; i < count; i++) {
            buff.append(", ?");
        }

        buff.append(")");
        return buff.toString();
    }

    /**
     * Converts the give list of Long objects to array.
     *
     * @param ids the ids list.
     * @return the ids array.
     */
    static long[] listToArray(List ids) {
        long[] result = new long[ids.size()];
        for (int i = 0; i < result.length; i++) {
            result[i] = ((Long) ids.get(i)).longValue();
        }

        return result;
    }
}
