/*
 * Copyright (C) 2007 TopCoder Inc., All Rights Reserved.
 */
package com.topcoder.management.project.persistence.accuracytests;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.util.Map;

import junit.framework.TestCase;
import junit.framework.TestSuite;
import junit.framework.Test;

import com.topcoder.management.project.Project;
import com.topcoder.management.project.ProjectCategory;
import com.topcoder.management.project.ProjectPropertyType;
import com.topcoder.management.project.ProjectStatus;
import com.topcoder.management.project.ProjectType;
import com.topcoder.management.project.persistence.AbstractInformixProjectPersistence;
import com.topcoder.management.project.persistence.UnmanagedTransactionInformixProjectPersistence;

/**
 * <p>
 * Accuracy Unit test cases for AbstractInformixProjectPersistence.
 * </p>
 *
 * @author victorsam
 * @version 1.1
 */
public class AbstractInformixProjectPersistenceAccuracyTests extends TestCase {
    /**
     * <p>
     * AbstractInformixProjectPersistence instance for testing.
     * </p>
     */
    private AbstractInformixProjectPersistence instance;

    /**
     * <p>
     * Setup test environment.
     * </p>
     * @throws Exception to JUnit
     *
     */
    protected void setUp() throws Exception {
        AccuracyTestHelper.loadXMLConfig(AccuracyTestHelper.CONFIG_FILE);
        AccuracyTestHelper.tearDownDataBase();
        AccuracyTestHelper.setUpDataBase();

        instance = new UnmanagedTransactionInformixProjectPersistence("InformixProjectPersistence.CustomNamespace");
    }

    /**
     * <p>
     * Tears down test environment.
     * </p>
     * @throws Exception to JUnit
     *
     */
    protected void tearDown() throws Exception {
        instance = null;

        AccuracyTestHelper.tearDownDataBase();
        AccuracyTestHelper.clearConfig();
    }

    /**
     * <p>
     * Return all tests.
     * </p>
     *
     * @return all tests
     */
    public static Test suite() {
        return new TestSuite(AbstractInformixProjectPersistenceAccuracyTests.class);
    }

    /**
     * <p>
     * Tests ctor AbstractInformixProjectPersistence#AbstractInformixProjectPersistence(String) for accuracy.
     * </p>
     */
    public void testCtor() {
        assertNotNull("Failed to create AbstractInformixProjectPersistence instance.", instance);
    }

    /**
     * <p>
     * Tests AbstractInformixProjectPersistence#createProject(Project,String) for accuracy.
     * </p>
     * @throws Exception to JUnit
     */
    public void testCreateProject() throws Exception {
        // create two different projects
        Project project1 = getProject(1, 2);
        Project project2 = getProject(2, 1);
        // set their properties
        project1.setProperty("property 1", "project1_value_1");
        project1.setProperty("property 2", "project1_value_2");
        project2.setProperty("property 2", "project2_value_2");
        project2.setProperty("property 3", "project2_value_3");

        // set two projects
        instance.createProject(project1, "accuracy_reviewer");
        instance.createProject(project2, "accuracy_reviewer");

        Connection con = AccuracyTestHelper.getConnection();

        // the project ids generated by the IDGenerator have been re-set to the project instance.
        long projectId1 = project1.getId();
        long projectId2 = project2.getId();
        // checks if the records exist in the table: project
        String sql = "SELECT * FROM project WHERE project_id = ?";
        assertTrue("The project does not exist in the database.", existsRecords(con, sql, new Object[] {new Long(
            projectId1)}));
        assertTrue("The project does not exist in the database.", existsRecords(con, sql, new Object[] {new Long(
            projectId2)}));

        // check if the records exist in the table: project_info
        sql = "SELECT * FROM project_info WHERE project_id = ? AND project_info_type_id = ? AND value = ?";
        assertTrue("The project does not exist in the database.", existsRecords(con, sql, new Object[] {
            new Long(projectId1), new Long(1), "project1_value_1"}));
        assertTrue("The project does not exist in the database.", existsRecords(con, sql, new Object[] {
            new Long(projectId1), new Long(2), "project1_value_2"}));
        assertTrue("The project does not exist in the database.", existsRecords(con, sql, new Object[] {
            new Long(projectId2), new Long(2), "project2_value_2"}));
        assertTrue("The project does not exist in the database.", existsRecords(con, sql, new Object[] {
            new Long(projectId2), new Long(3), "project2_value_3"}));
    }

    /**
     * <p>
     * Tests AbstractInformixProjectPersistence#getAllProjectPropertyTypes() for accuracy.
     * </p>
     * @throws Exception to JUnit
     */
    public void testGetAllProjectPropertyTypes() throws Exception {
        ProjectPropertyType[] projectPropertyTypes = instance.getAllProjectPropertyTypes();
        // test the number
        assertEquals("The total number of projectPropertyTypes is incorrect.", 4, projectPropertyTypes.length);
        // test the accuracy
        for (int i = 0; i < projectPropertyTypes.length; i++) {
            boolean flag = false;
            if (projectPropertyTypes[i].getId() == 1 && projectPropertyTypes[i].getName().equals("property 1")
                && projectPropertyTypes[i].getDescription().equals("project property 1")) {
                flag = true;
            } else if (projectPropertyTypes[i].getId() == 2 && projectPropertyTypes[i].getName().equals("property 2")
                && projectPropertyTypes[i].getDescription().equals("project property 2")) {
                flag = true;
            } else if (projectPropertyTypes[i].getId() == 3 && projectPropertyTypes[i].getName().equals("property 3")
                && projectPropertyTypes[i].getDescription().equals("project property 3")) {
                flag = true;
            } else if (projectPropertyTypes[i].getId() == 4 && projectPropertyTypes[i].getName().equals("property 4")
                && projectPropertyTypes[i].getDescription().equals("project property 4")) {
                flag = true;
            }
            assertTrue("The type is not set properly.", flag);
        }
    }

    /**
     * <p>
     * Tests AbstractInformixProjectPersistence#updateProject(Project,String,String) for accuracy.
     * </p>
     * @throws Exception to JUnit
     */
    public void testUpdateProject() throws Exception {
        // create the project
        Project project = getProject(1, 1);
        project.setProperty("property 1", "value 1");

        instance.createProject(project, "accuracy_reviewer");
        project.setProperty("property 2", "new value 2");
        project.setProperty("property 3", "new value 3");
        // update
        instance.updateProject(project, "For tests", "tcs_reviewer");

        Connection con = AccuracyTestHelper.getConnection();
        String sql = "SELECT * FROM project_info WHERE project_id = ? AND project_info_type_id = ? AND modify_user = ?";
        // the original record still exists
        assertTrue("The original record should still exist.", existsRecords(con, sql, new Object[] {
            new Long(project.getId()), new Long(1), "tcs_reviewer"}));
        // new record exists
        assertTrue("The new record should exist", existsRecords(con, sql, new Object[] {new Long(project.getId()),
            new Long(2), "tcs_reviewer"}));
        assertTrue("The new record should exist", existsRecords(con, sql, new Object[] {new Long(project.getId()),
            new Long(3), "tcs_reviewer"}));
        con.close();
    }

    /**
     * <p>
     * Tests AbstractInformixProjectPersistence#getProject(long) for accuracy.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testGetProject() throws Exception {
        // create three different projects
        Project project = getProject(1, 1);
        // set the properties
        project.setProperty("property 1", "1_1");
        project.setProperty("property 2", "1_2");
        // do the persistence
        instance.createProject(project, "accuracy_reviewer");

        Project projectRes = instance.getProject(project.getId());

        // tests not null
        assertNotNull("It should not be null", projectRes);
        // tests the accuracy of the project

        // test the category id
        assertEquals("The category id is set incorrectly.", 1, projectRes.getProjectCategory().getId());
        // test the status id
        assertEquals("The status id is set incorrectly.", 1, projectRes.getProjectStatus().getId());
        // test the property
        assertEquals("The property is not set properly.", "1_1", projectRes.getProperty("property 1"));
        assertEquals("The property is not set properly.", "1_2", projectRes.getProperty("property 2"));
    }

    /**
     * <p>
     * Tests AbstractInformixProjectPersistence#getProjects([J) for accuracy.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testGetProjects() throws Exception {
        // create three different projects
        Project project1 = getProject(1, 1);
        Project project2 = getProject(2, 2);
        Project project3 = getProject(1, 2);
        // set the properties
        project1.setProperty("property 1", "1_1");
        project1.setProperty("property 2", "1_2");
        project2.setProperty("property 2", "2_2");
        // do the persistence
        instance.createProject(project1, "accuracy_reviewer");
        instance.createProject(project2, "accuracy_reviewer");
        instance.createProject(project3, "accuracy_reviewer");

        Project[] projects = instance.getProjects(new long[] {project1.getId(), project2.getId(), project3.getId()});

        // tests the number
        assertEquals("It should contains 3 elements.", 3, projects.length);
        // tests the accuracy of the project 1
        int i;
        for (i = 0; i < projects.length; i++) {
            if (projects[i].getId() == project1.getId()) {
                break;
            }
        }
        if (i == projects.length) {
            fail("The project is not found by the getProjects method.");
        }
        // test the category id
        assertEquals("The category id is set incorrectly.", 1, projects[i].getProjectCategory().getId());
        // test the status id
        assertEquals("The status id is set incorrectly.", 1, projects[i].getProjectStatus().getId());
        // test the property
        assertEquals("The property is not set properly.", "1_1", projects[i].getProperty("property 1"));
        assertEquals("The property is not set properly.", "1_2", projects[i].getProperty("property 2"));

        // tests the accuracy of the project 2
        for (i = 0; i < projects.length; i++) {
            if (projects[i].getId() == project2.getId()) {
                break;
            }
        }
        if (i == projects.length) {
            fail("The project is not found by the getProjects method.");
        }
        // test the category id
        assertEquals("The category id is set incorrectly.", 2, projects[i].getProjectCategory().getId());
        // test the status id
        assertEquals("The status id is set incorrectly.", 2, projects[i].getProjectStatus().getId());
        // test the property
        assertEquals("The property is not set properly.", "2_2", projects[i].getProperty("property 2"));

        // tests the accuracy of the project 3
        for (i = 0; i < projects.length; i++) {
            if (projects[i].getId() == project3.getId()) {
                break;
            }
        }
        if (i == projects.length) {
            fail("The project is not found by the getProjects method.");
        }
        // test the category id
        assertEquals("The category id is set incorrectly.", 1, projects[i].getProjectCategory().getId());
        // test the status id
        assertEquals("The status id is set incorrectly.", 2, projects[i].getProjectStatus().getId());
        // test the property
        Map properties = projects[i].getAllProperties();
        assertTrue("The properties should be empty.", properties.isEmpty());
    }

    /**
     * <p>
     * Tests AbstractInformixProjectPersistence#getAllProjectTypes() for accuracy.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testGetAllProjectTypes() throws Exception {
        ProjectType[] projectTypes = instance.getAllProjectTypes();
        // test the number
        assertEquals("The total number of projectTypes is incorrect.", 2, projectTypes.length);
        // test the accuracy
        for (int i = 0; i < projectTypes.length; i++) {
            boolean flag = false;
            if (projectTypes[i].getId() == 1 && projectTypes[i].getName().equals("Topcoder")
                && projectTypes[i].getDescription().equals("Topcoder Component")) {
                flag = true;
            } else if (projectTypes[i].getId() == 2 && projectTypes[i].getName().equals("Customer")
                && projectTypes[i].getDescription().equals("Customer Component")) {
                flag = true;
            }
            assertTrue("The type is not set properly.", flag);
        }
    }

    /**
     * <p>
     * Tests AbstractInformixProjectPersistence#getAllProjectCategories() for accuracy.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testGetAllProjectCategories() throws Exception {
        ProjectCategory[] projectCategories = instance.getAllProjectCategories();
        // test the number
        assertEquals("The total number of projectCategories is incorrect.", 4, projectCategories.length);
        // test the accuracy
        for (int i = 0; i < projectCategories.length; i++) {
            boolean flag = false;
            if (projectCategories[i].getId() == 1 && projectCategories[i].getProjectType().getId() == 1
                && projectCategories[i].getName().equals(".Net")
                && projectCategories[i].getDescription().equals(".NET Component")) {
                flag = true;
            } else if (projectCategories[i].getId() == 2 && projectCategories[i].getProjectType().getId() == 1
                && projectCategories[i].getName().equals("Java")
                && projectCategories[i].getDescription().equals("JAVA Component")) {
                flag = true;
            } else if (projectCategories[i].getId() == 3 && projectCategories[i].getProjectType().getId() == 2
                && projectCategories[i].getName().equals("Customer .Net")
                && projectCategories[i].getDescription().equals("Customer .NET Component")) {
                flag = true;
            } else if (projectCategories[i].getId() == 4 && projectCategories[i].getProjectType().getId() == 2
                && projectCategories[i].getName().equals("Customer Java")
                && projectCategories[i].getDescription().equals("Customer JAVA Component")) {
                flag = true;
            }
            assertTrue("The type is not set properly.", flag);
        }
    }

    /**
     * <p>
     * Tests AbstractInformixProjectPersistence#getAllProjectStatuses() for accuracy.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testGetAllProjectStatuses() throws Exception {
        ProjectStatus[] projectStatuses = instance.getAllProjectStatuses();
        // test the number
        assertEquals("The total number of projectStatuses is incorrect.", 7, projectStatuses.length);
        // test the accuracy
        for (int i = 0; i < projectStatuses.length; i++) {
            boolean flag = false;
            if (projectStatuses[i].getId() == 1 && projectStatuses[i].getName().equals("Active")
                && projectStatuses[i].getDescription().equals("Active")) {
                flag = true;
            } else if (projectStatuses[i].getId() == 2 && projectStatuses[i].getName().equals("Inactive")
                && projectStatuses[i].getDescription().equals("Inactive")) {
                flag = true;
            } else if (projectStatuses[i].getId() == 3 && projectStatuses[i].getName().equals("Deleted")
                && projectStatuses[i].getDescription().equals("Deleted")) {
                flag = true;
            } else if (projectStatuses[i].getId() == 4
                && projectStatuses[i].getName().equals("Cancelled - Failed Review")
                && projectStatuses[i].getDescription().equals("Cancelled - Failed Review")) {
                flag = true;
            } else if (projectStatuses[i].getId() == 5
                && projectStatuses[i].getName().equals("Cancelled - Failed Screening")
                && projectStatuses[i].getDescription().equals("Cancelled - Failed Screening")) {
                flag = true;
            } else if (projectStatuses[i].getId() == 6
                && projectStatuses[i].getName().equals("Cancelled - Zero Submissions")
                && projectStatuses[i].getDescription().equals("Cancelled - Zero Submissions")) {
                flag = true;
            } else if (projectStatuses[i].getId() == 7 && projectStatuses[i].getName().equals("Completed")
                && projectStatuses[i].getDescription().equals("Completed")) {
                flag = true;
            }
            assertTrue("The type is not set properly.", flag);
        }
    }

    /**
     * Gets a specific project with the given category id and status id.
     *
     * No properties are set in the returned project.
     *
     * @param categoryId the category id
     * @param statusId the status id
     *
     * @return the project with given information
     */
    private Project getProject(int categoryId, int statusId) {
        // create the project type, the id is mocked
        ProjectType type = new ProjectType(1, "something");
        // create the project category
        ProjectCategory category = new ProjectCategory(categoryId, "something", type);
        // create the project status
        ProjectStatus status = new ProjectStatus(statusId, "something");
        // create the project without id
        Project project = new Project(category, status);
        return project;
    }

    /**
     * Checks if there are records with the given sql statement.
     *
     * @param con the connection
     * @param sql the sql statement
     * @param values the values to set in the dql statement
     *
     * @return true if the statement exists, otherwise false
     */
    private boolean existsRecords(Connection con, String sql, Object[] values) {
        PreparedStatement ps = null;
        ResultSet rs = null;
        try {
            ps = con.prepareStatement(sql);
            rs = doQuery(con, sql, values, ps);
            return rs.next();
        } catch (SQLException e) {
            // ignore
            e.printStackTrace();
        } finally {
            try {
                rs.close();
            } catch (SQLException e) {
                // ignore
            }
            try {
                ps.close();
            } catch (SQLException e) {
                // ignore
            }
        }
        return false;
    }

    /**
     * Does the query operation with a specific sql statement and values.
     *
     * @param con the connection
     * @param sql the sql statement
     * @param values the values to set in the sql statement
     * @param ps the PreparedStatement instance
     *
     * @return the result in the form of ResultSet
     */
    private ResultSet doQuery(Connection con, String sql, Object[] values, PreparedStatement ps) {
        ps = null;
        try {
            ps = con.prepareStatement(sql);
            for (int i = 0; i < values.length; i++) {
                setElement(ps, i + 1, values[i]);
            }
            return ps.executeQuery();
        } catch (SQLException e) {
            // ignore
            e.printStackTrace();
        }
        return null;
    }

    /**
     * Sets the values to the prepared statement.
     *
     * @param ps the object of PreparedStatement
     * @param index the index of the value
     * @param obj the value
     *
     * @throws SQLException if any error occurs
     */
    private void setElement(PreparedStatement ps, int index, Object obj) throws SQLException {
        if (obj instanceof Integer) {
            ps.setInt(index, ((Integer) obj).intValue());
        } else if (obj instanceof Long) {
            ps.setLong(index, ((Long) obj).longValue());
        } else if (obj instanceof Timestamp) {
            ps.setTimestamp(index, (Timestamp) obj);
        } else if (obj instanceof String) {
            ps.setString(index, (String) obj);
        } else {
            throw new IllegalArgumentException("The type of the obj is not supported.");
        }
    }

}